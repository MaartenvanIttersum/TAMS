#!/bin/ksh
#######################################################
#	TAMS (Trajectory Analysis and Mining Software
#
#	Written for the analysis of pain trajectories in LBP
# 	Author: M.v.Ittersum
#	Date:	May 2019 - ...
#######################################################


if [ $# -lt 5 ] ; then 
        echo "Usage: $0 output file parameter first_group nr_of_groups second_group nr_of_groups third_group nr_of_groups"
	echo " "
	echo "	Output		= 0=stdOut, 1=AgregateFile, 2=RawData, 3=Bruteforce"
	echo "	File		= the CSV data file"
	echo "	Parameter	= The column number of the parameter to analyze"
	echo "	First group	= Column number of the first subgroup"
	echo " 	Nr_of_groups	= The number of groups to devide the first subgroup in"
	echo "	Second group	= (Optional) Column number of the second subgroup"
	echo "	Nr_of_groups	= (Optional) The number of groups to devide the second subgroup in"
	echo "	Third group	= (Optional) Column number of the third subgroup"
	echo "	Nr_of_groups	= (Optional) The number of groups to devide the third subgroup in"
	echo " "
	echo "  Example: $0 2 DATASET_Exercise.csv 30 8 2 7 4 27 4"
	echo " "
	echo "  Some interesting columns in the LBP IPD dataset are:"
	echo "  8 = Sex"
	echo "  7 = Age"
	echo "  27 = BMI"
	echo "  30 = Pain"
	echo "  31 = Baseline Roland Morris Disability Questionnaire sum"
        exit;
        exit;
fi

OUTPUT_OPTION=$1;
FILE=$2;
PARAM_NUMBER=$3;
FIRST_GROUP=$4;
FIRST_GROUP_NUMBER=$5;
SECOND_GROUP=$6;
SECOND_GROUP_NUMBER=$7;
THIRD_GROUP=$8;
THIRD_GROUP_NUMBER=$9;

if [ $# -eq 5 ] ; then
	SUBGROUP_NUMBER=1;
elif [ $# -eq 7 ] ; then
	SUBGROUP_NUMBER=2;
elif [ $# -eq 9 ] ; then
        SUBGROUP_NUMBER=3;
else
	echo "There is a problem with the number of subgroups.";
	exit;
fi

FILENAME=`basename $FILE|awk -F. '{print $1}'`

cat ${FILE} | awk -v PN=$PARAM_NUMBER \
                        -v FG=$FIRST_GROUP \
                        -v SG=$SECOND_GROUP \
                        -v TG=$THIRD_GROUP \
			-v NUMBER_OF_SUBGROUPS=$SUBGROUP_NUMBER \
                        -F, ' {
	line=$1","$2","$3","$PN","$FG;
if(NUMBER_OF_SUBGROUPS>=2){
	line=line","$SG;
}
if(NUMBER_OF_SUBGROUPS>=3){
	line=line","$TG;
}
print line		
}' > ${FILENAME}.slim


cat ${FILENAME}.slim | awk -v PN=4 \
			-v FG=5 \
			-v SG=6 \
			-v TG=7 \
			-v NUMBER_OF_SUBGROUPS=$SUBGROUP_NUMBER \
			-F, '{
	if(NR==1){
		print;
	}else{
	        for(i=1;i<=NF;i++){
	                if($FG==9999||$FG==9997||$FG==""){     # no first group information is no entry
	                        next;
	                }
			if(NUMBER_OF_SUBGROUPS>=2){
	                	if($SG==9999||$SG==9997||$SG==""){     # no second group information is no entry
	                        	next;
	                	}
			}
			if(NUMBER_OF_SUBGROUPS>=3){
	                	if($TG==9999||$TG==9997||$TG==""){     # no third group information is no entry
	                        	next;
	                	}
			}
	                if(i==PN){
	                        if($i==9999||$i==9997||$i==""||$i==999999){         # no parameter info is no entry
	                                next;
				}
	                }
	                if(i==1){
	                        string=$i
	                }else{ 
	                        string=string","$i
	                }
	        }
	        print string;
	}
}' > ${FILENAME}.tmp

if [[ `cat ${FILENAME}.tmp |wc -l` -lt 2 ]] ; then
	exit;
fi 

cat ${FILENAME}.tmp | gawk -v PN=4 \
	-v FG=5 -v FGN=$FIRST_GROUP_NUMBER \
	-v SG=6 -v SGN=$SECOND_GROUP_NUMBER \
	-v TG=7 -v TGN=$THIRD_GROUP_NUMBER \
	-v NUMBER_OF_SUBGROUPS=$SUBGROUP_NUMBER \
	-v DATASET_NAME=$FILENAME \
	-F, '

############################################################3
#
#	Function: calcAvg
#	Returns: the average value of an array
#	Args: array with values, number of elements in array
#
############################################################3

	function calcAvg(values,cnt) {
	        total=0;avg=0;
	        if(cnt>0){
	                for(i=0;i<cnt;i++) {
	                        total+=values[i];     
	                }
	                avg=total/cnt;
	        }
	        return avg;
	}

############################################################3
#
#	Function: calcStdDev
#	Returns: the standard deviation of an array
#	Args: array with values, number of elements in array
#
############################################################3

	function calcStdDev(values,cnt) {
	        totdevsq=0;devsq=0;dev=0;bessel=0;variance=0;
	        if(cnt>1){
	                average=calcAvg(values,cnt);
	                for(i=0;i<cnt;i++){
	                        dev=values[i]-average;
	                        devsq=dev*dev;
	                        totdevsq+=devsq;
	                }
	                bessel=cnt-1;
			if(bessel!=0){
	                	variance=totdevsq/bessel;
			}
	                stddev=sqrt(variance);
	        }else{
	                stddev=0;
	        }
	        return stddev;
	}

############################################################3
#
#	Function: getMax
#	Returns: the largest value of an array
#	Args: array with values, number of elements in array
#
############################################################3

	function getMax(values,cnt){
	        max=0;
	        for(i=0;i<cnt;i++) {
	                if(values[i]>max){
	                        max=values[i];
	                }
	        }
	        return max;
	}

############################################################3
#
#	Function: getMin
#	Returns: the smallest value of an array
#	Args: array with values, number of elements in array
#
############################################################3

	function getMin(values,cnt){
		if(cnt>0){
		        min=100;
	       	 	for(i=0;i<cnt;i++) {
	               	 	if(values[i]<min){
	                        	min=values[i];
	                	}
	        	}
		}else{
			min=0;
		}
	        return min;
	}

############################################################3
#
#	Function: calcMoving
#	Returns: the moving average of an array
#	Args: array with values, number of elements in array
#
#  	Currently unused
#
############################################################3

	function calcMoving(data_array,count,period,patientID){
		moving=-1;	
		if(patientID!=""){
		        totally=0;
		        totcount=0;
		        arcount=0
		        for(ietje=0;ietje<100;ietje++){
		                for(jetje=ietje;jetje<ietje+period;jetje++){
		                        printline=printline","jetje
		                        for(k=0;k<count;k++){
		                                if(data_array[0,k]==jetje){
		                                        avg_arr[arcount]=data_array[1,k]
		                                        arcount++;
		                                }
		                        }
				}
		                if(arcount!=0){
		                        avg1=calcAvg(avg_arr,arcount);
		                        totally+=avg1;
		                        totcount++;
		                }
		                arcount=0
		                for(var in avg_arr){
		                        delete avg_arr[var];
		                }
		                printline="";
		        }
			if(totcount!=0){
				moving=totally/totcount;
			}
		}
	        return moving;
	}


function assess_Trajectory(data_array, cnt, patientId){
	if(cnt!=0){
	        trajectoryId=0;
	
	        for(i=0;i<cnt;i++){
	                if(i==0){
	
# trajectory parameters initialisation
	
	                        startWeek=data_array[0,i];
	                        startValue=data_array[1,i];
	                        seperateFUcnt=0;
	                        constant_pain=0;
	                        weeksPain=0;
				weeksNoPain=0;
				mainly_zero=0;
	                        multipleEpisodes=0;
				directionCoefficient=0;
	                        maxDirectionCoefficient=0;
	                        painIncrease=0;
	                        painDecrease1=0;
	                        varianceMoreThenOne=0;
	                        increaseFromBaseline=0;
	                        directionChange=0;
	                        directionChangeCNT=0;
	                        significantValueChange=0;
	                        significantDirectionChange=0;
	                        significantNegativeValueChange=0;
				significantNegativeValueChangeFLAG=0;
				continuousPainFreeWeeks=0;
	                        painFree4Weeks=0;
				increaseFromBaseline=0;
				valueTotalForMean=startValue;
	                        previousMeasurement=startValue;
	                        previousMeasurementFU=startWeek;
				episodeCNT=0;
				if(startValue>0){
					weeksPain=1;	
					painFlag=1;
				}else{
					weeksNoPain=1;
					painFlag=0;
				}
	                }else{
	                        seperateFUcnt++;
	                        followUpWeek=data_array[0,i];
	                        currentValue=data_array[1,i];
	                        valueChange=previousMeasurement-currentValue;
	                        periodChange=followUpWeek-previousMeasurementFU;
	
				thisValueChange=currentValue-previousMeasurement;
				if(periodChange==1){
					valueTotalForMean+=currentValue;
				}else{
	        	               	valueTotalForMean+=((thisValueChange/2)+previousMeasurement)*periodChange;
				}
	                        if(currentValue!=0){
	                                weeksPain+=periodChange;
					if(painFlag!=1){
						painFlag=1;
						episodeCNT++;
					}
	                        }else{
					weeksNoPain+=periodChange;
					if(painFlag==1){
						painFlag=0;
					}
				}
	                        if(periodChange!=0){
	                                directionCoefficient=valueChange/periodChange;
	                        }
	                        if(directionCoefficient<maxDirectionCoefficient){
	                                maxDirectionCoefficient=directionCoefficient;
	                        }
	                        if(valueChange<0){
	                                painIncrease++;
	                                if(valueChange<=-30){
	                                        significantNegativeValueChange++;
						significantNegativeValueChangeFLAG=1;
	                                }
	                        }else if(valueChange>0){
	                                painDecrease++;
	                                if(valueChange>=30){
	                                        significantValueChange++;
	                                }
	                        }
# First treatment effect
	                        if(previousMeasurementFU==0){
	                        	if(currentValue>startValue){
	                               		increaseFromBaseline=1;
	                                }
	                        }
	
# Changing direction?
# Previous point was NOT BASELINE
	                        if(directionChange!=0){
	                                if(valueChange>0){
	                                        continuousPainFreeWeeks=0;
# pain decreasing
	                                        if(directionChange!=1){
	                                                directionChange=1;
	                                                directionChangeCNT++;
	                                                if(valueChange>=30){
	                                                        significantDirectionChange++;
	                                                }
	                                        }
	                                }else if(valueChange<0){
# pain increasing
	                                        continuousPainFreeWeeks=0;
	                                        if(directionChange!=-1){
	                                                directionChange=-1;
	                                                directionChangeCNT++;
	                                                if(valueChange<=-30){
	                                                        significantDirectionChange++;
	                                                }
	                                        }else{
# pain was already increasing, maybe combination is significant?
# only in weekly dataset?
	                                                if(periodChange==1){
	                                                        if(significantNegativeValueChangeFLAG==0){
	                                                                if(valueChange+prevValueChange<=-30){
	                                                                        significantNegativeValueChange++;
										significantNegativeValueChangeFLAG=1;
	                                                                }
	                                                        }
	                                                }
	                                        }
	                                }else if(valueChange==0){
	                                        if(currentValue==0){
	                                                continuousPainFreeWeeks+=periodChange;
	                                                if(continuousPainFreeWeeks>=3){
	                                                                painFree4Weeks=1;
	                                                        if(multipleEpisodes==0){
	                                                                multipleEpisodes=1;
	                                                        }else{
	                                                                multipleEpisodes++;
	                                                        }
	                                                }
	                                        }
	                                }
	                        }else{
# Previous point was BASELINE
	                                if(seperateFUcnt>1){
# No change from baseline
	                                        if(valueChange>0){
	                                                directionChange=1;
	                                                directionChangeCNT++;
	                                        }else if(valueChange<0){
	                                                directionChange=-1;
	                                                directionChangeCNT++;
	                                        }else if(valueChange==0){
	                                                if(currentValue==0){
	                                                        continuousPainFreeWeeks+=periodChange;
	                                                        if(continuousPainFreeWeeks>=3){
	                                                                        painFree4Weeks=1;
	                                                                if(multipleEpisodes==0){
	                                                                        multipleEpisodes=1;
	                                                                }else{
	                                                                        multipleEpisodes++;
	                                                                }
	                                                        }
	                                                }
	                                        }
	                                }else{
# previous was baseline
	                                        if(valueChange>0){
	                                                directionChange=1;
	                                        }else if(valueChange<0){
	                                                directionChange=-1;
	                                        }else if(valueChange==0){
	                                                if(currentValue==0){
	                                                        continuousPainFreeWeeks+=periodChange;
	                                                        if(continuousPainFreeWeeks>=3){
	                                                                        painFree4Weeks=1;
	                                                                if(multipleEpisodes==0){
	                                                                        multipleEpisodes=1;
	                                                                }else{
	                                                                        multipleEpisodes++;
	                                                                }
	                                                        }
	                                                }else{
# count episode if first and second are non zero
								episodeCNT++;
							}
	                                        }
	                                }
	                        }
	
	                        previousMeasurement=currentValue;
	                        previousMeasurementFU=followUpWeek;
	                        prevValueChange=valueChange;
	                }
	                painArray[i]=data_array[1,i];
			painString[patientId]=painString[patientId]","data_array[1,i];
	        }
	
	
#####################################################
#
#	Mean Pain
#
#####################################################
	
		AUC_denominator=(followUpWeek+1)-startweek;
	
	# USING Nearest neighbor MEAN PAIN
			if(AUC_denominator!=0){
				meanPain=valueTotalForMean/AUC_denominator;
			}
	
		if(AUC_denominator!=0){
			meanPain_AUC=valueTotalForMean/AUC_denominator;
		}
	
	        minPain=getMin(painArray,cnt);
	        if(minPain>0){
	                 constant_pain=1;
	        }
		if(weeksNoPain/(seperateFUcnt+1)>0.90){
			mainly_zero=1;
		}
	        maxPain=getMax(painArray,cnt);
	
	        for(i=0;i<cnt;i++){
	                if((meanPain-painArray[i]<-10)||(meanPain-painArray[i]>10)){
	                        varianceMoreThenOne=1;
	                }
	        }
	
	
#####################################################
#
# TRAJECTORY LOGIC KONGSTED et al. 2017
#
#####################################################
	
	        if(cnt==0){
	                trajectoryId=-1;
	        }else{
	                if(varianceMoreThenOne==0){
# PatientsWithPersistentPain
	                        if((meanPain<20)&&((painFree4Weeks==0)||constant_pain==0)){
	
					if(weeksPain==1){
	                                	trajectoryId=16;
					}else if((weeksPain>1&&weeksPain<3)&&episodeCNT<2){
	                                	trajectoryId=16;
					}else if(weeksPain>1&&weeksPain<5){
	                                	trajectoryId=12;
					}else if(painFree4Weeks>0&&weeksPain>2){
	                                	trajectoryId=12;
					}else{
	                                	trajectoryId=4;
					}
	                        }else if(meanPain<40){
	                                trajectoryId=3;
	                        }else if(meanPain<60){
	                                trajectoryId=2;
	                        }else if(meanPain>=60){
	                                trajectoryId=1;
	                        }else{
	                                trajectoryId=17;
	                        }
	
	                }else if(((meanPain-minPain>10)||(maxPain-meanPain>10))&&painFree4Weeks==0){
# PatientsWithFluctuatingPain
	                        if(meanPain<20){
	                                trajectoryId=8;
	                        }else if(meanPain<40){
	                                trajectoryId=7;
	                        }else if(meanPain<60){
	                                trajectoryId=6;
	                        }else if(meanPain>=60){
	                                trajectoryId=5;
	                        }
	                }else if(((meanPain-minPain>10)||(maxPain-meanPain>10))&&painFree4Weeks==1){
	                        if(weeksPain<=2&&directionChangeCNT<=2){
# PatientsWithSingleEpisodicPain
	                                if(maxPain<20){
	                                        trajectoryId=16;
	                                }else if(maxPain<40){
	                                        trajectoryId=15;
	                                }else if(maxPain<60){
	                                        trajectoryId=14;
	                                }else if(maxPain>=60){
	                                        trajectoryId=13;
	                                }
	                        }else{
# PatientsWithEpisodicPain
	                                if(maxPain<20){
	                                        trajectoryId=12;
	                                }else if(maxPain<40){
	                                        trajectoryId=11;
	                                }else if(maxPain<60){
	                                        trajectoryId=10;
	                                }else if(maxPain>=60){
	                                        trajectoryId=9;
	                                }
	                        }
	                }else{
# RestPatients
	                        trajectoryId=17;
	                }
	        }
		print "PATIENTDATA "patientId","trajectoryId","meanPain","minPain","maxPain","\
			painFree4Weeks","constant_pain","varianceMoreThenOne","weeksPain","\
			directionChangeCNT","continuousPainFreeWeeks","moving_avg2","moving_avg4","\
			moving_avg6","moving_avg12","meanPain_AUC","valueTotalForMean","followUpWeek","startWeek","painString[patientId];
	
	        return trajectoryId;
	}
}


function assess_First_Trajectory(data_array, FUcnt1, patientId){
	if(FUcnt1!=0){
	        trajectoryId=0;
	        for(i=0;i<FUcnt1;i++){
	
	
	                if(i==0){
				course=data_array[1,i];
	                        startWeek=data_array[0,i];
	                        startValue=data_array[1,i];
				EPItotal=data_array[1,i];
				EPIcounter=1;
				baselineValue=startValue;
	                        seperateFUcnt=0;
	                        constant_pain=0;
	                        weeksPain=0;
	            		weeksNoPain=0;
	            		mainly_zero=0;
	                        multipleEpisodes=0;
				detectedEpisoded=0;
				resolved=0;
				RAPID=0;
	            		directionCoefficient=0;
	                        maxDirectionCoefficient=0;
	                        painIncrease=0;
	                        painDecrease1=0;
	                        varianceMoreThenOne=0;
	                        increaseFromBaseline=0;
	                        directionChange=0;
	                        directionChangeCNT=0;
	                        significantValueChange=0;
	                        significantDirectionChange=0;
	                        significantNegativeValueChange=0;
	            		significantNegativeValueChangeFLAG=0;
				significantFluctuations=0;
	            		continuousPainFreeWeeks=0;
	                        painFree4Weeks=0;
	            		increaseFromBaseline=0;
	            		valueTotalForMean=startValue;
				valueTotalForMeanWithoutBaseline=0;
	                        previousMeasurement=startValue;
	                        previousMeasurementFU=startWeek;
	            		episodeCNT=0;
	            		if(startValue>0){
	                		weeksPain=1;    
	                		painFlag=1;
	                		episodeCNT++;
					recurrenceFLAG=1;
	                                FOLLOWUPcounter++;
	                                EpiTotal=startValue;
	            		}else{
	                		weeksNoPain=1;
	                		painFlag=0;
					recurrenceFLAG=0;
	            		}
	                }else{
	
				course=course","data_array[1,i];
	                        seperateFUcnt++;
	                        followUpWeek=data_array[0,i];
	                        currentValue=data_array[1,i];
				EPItotal+=data_array[1,i];
				EPIcounter++;
	                        valueChange=previousMeasurement-currentValue;
	                        periodChange=followUpWeek-previousMeasurementFU;
				if(firstWeekAfterBaseline==0){
					firstWeekAfterBaseline=data_array[0,i];
				}
	            		thisValueChange=currentValue-previousMeasurement;
	                        if(periodChange==1){
	                                valueTotalForMean+=currentValue;
	                        }else{
	                                valueTotalForMean+=((thisValueChange/2)+previousMeasurement)*periodChange;
	                        }
	
	                        if(currentValue!=0){
	                                weeksPain+=periodChange;
	                		if(painFlag!=1){
	                    			painFlag=1;
	                    			episodeCNT++;
	                		}
	                        }else{
	                		weeksNoPain+=periodChange;
	                		if(painFlag==1){
	                    			painFlag=0;
	                		}
	            		}
	                        if(periodChange!=0){
	                                directionCoefficient=valueChange/periodChange;
	                        }
	                        if(directionCoefficient<maxDirectionCoefficient){
	                                maxDirectionCoefficient=directionCoefficient;
	                        }
	                        if(valueChange<0){
	                                painIncrease++;
	                                if(valueChange<=-30){
	                                        significantNegativeValueChange++;
	                    			significantNegativeValueChangeFLAG=1;
	                                }
	                        }else if(valueChange>0){
	                                painDecrease++;
	                                if(valueChange>=30){
	                                        significantValueChange++;
	                                }
					if(baselineValue-currentValue>=30){
						if(followUpWeek<5){
							RAPID=1;
						}
					}
	                        }
				if((valueChange<=-30)||(valueChange>=30)){
					significantFluctuations++;
				}
# First treatment effect
	                        if(previousMeasurementFU==0){
	                            if(currentValue>startValue){
	                                       increaseFromBaseline=1;
	                                }
	                        }
	
# Changing direction?
# Previous point was NOT BASELINE
	                        if(directionChange!=0){
	                                if(valueChange>0){
	                                        continuousPainFreeWeeks=0;
# pain decreasing
	                                        if(directionChange!=1){
	                                                directionChange=1;
	                                                directionChangeCNT++;
	                                                if(valueChange>=30){
	                                                        significantDirectionChange++;
	                                                }
	                                        }
						
						if(currentValue==0){
							recurrenceFLAG=0;
							if(FOLLOWUPcounter!=0){
								epiMeanPain=EpiTotal/FOLLOWUPcounter;
							}else{
								epiMeanPain=0;
							}
	
							FOLLOWUPcounter=0;
							EpiTotal=0;
						}
	
	
	                                }else if(valueChange<0){
# pain increasing
	                                        continuousPainFreeWeeks=0;
						EPI_FLAG=0;
						if(painFree4Weeks>0){
							painFree4Weeks=0;
	                				EPIcounter=1;
	                				EPItotal=currentValue;
							recurrenceFLAG=1;
						}
	                                        if(directionChange!=-1){
	                                                directionChange=-1;
	                                                directionChangeCNT++;
	                                                if(valueChange<=-30){
	                                                        significantDirectionChange++;
	                                                }
	                                        }else{
# pain was already increasing, may combination is significant?
# only in weekly dataset?
	                                                if(periodChange==1){
	                                                        if(significantNegativeValueChangeFLAG==0){
	                                                                if(valueChange+prevValueChange<=-30){
	                                                                        significantNegativeValueChange++;
	                                    					significantNegativeValueChangeFLAG=1;
	                                                                }
	                                                        }
	                                                }
	                                        }
	                                }else if(valueChange==0){
	                                        if(currentValue==0){
	                                                continuousPainFreeWeeks+=periodChange;
	                                                if(continuousPainFreeWeeks==3){
								detectedEpisoded++;
								EPI_FLAG=1;
	                					EPIweek=EPIcounter-4;
	                					EpisodeMean=EPItotal/EPIweek;
	                					EpisodeDescriptionString[patientId]=EpisodeDescriptionString[patientId]","detectedEpisoded","EPIweek","EpisodeMean;
	                                                        painFree4Weeks=1;
	                                                        if(multipleEpisodes==0){
	                                                               	multipleEpisodes=1;
	                                                        }else{
	                                                               	multipleEpisodes++;
	                                                        }
	                                                }
	                                        }
	                                }
	                        }else{
# Previous point was BASELINE
	                                if(seperateFUcnt>1){
# No change from baseline
	                                        if(valueChange>0){
	                                                directionChange=1;
	                                                directionChangeCNT++;
	                                        if(currentValue==0){
	                                                recurrenceFLAG=0;
	                                                FOLLOWUPcounter=0;
	                                                EpiTotal=0;
	                                        }
	
	
	                                        }else if(valueChange<0){
	                                                directionChange=-1;
	                                                directionChangeCNT++;
	                                        }else if(valueChange==0){
	                                                if(currentValue==0){
	                                                        continuousPainFreeWeeks+=periodChange;
	                                                        if(continuousPainFreeWeeks>=3){
	                                                                        painFree4Weeks=1;
	                                                                if(multipleEpisodes==0){
	                                                                        multipleEpisodes=1;
	                                                                }else{
	                                                                        multipleEpisodes++;
	                                                                }
	                                                        }
	                                                }
	                                        }
	                                }else{
# previous was baseline
	                                        if(valueChange>0){
	                                                directionChange=1;
	                                        if(currentValue==0){
	                                                recurrenceFLAG=0;
	                                                FOLLOWUPcounter=0;
	                                                EpiTotal=0;
						}
	                                        }else if(valueChange<0){
	                                                directionChange=-1;
	                                        }else if(valueChange==0){
	                                                if(currentValue==0){
	                                                        continuousPainFreeWeeks+=periodChange;
	                                                        if(continuousPainFreeWeeks>=3){
	                                                                        painFree4Weeks=1;
	                                                                if(multipleEpisodes==0){
	                                                                        multipleEpisodes=1;
	                                                                }else{
	                                                                        multipleEpisodes++;
	                                                                }
	                                                        }
	                                                }else{
# count episode if first and second are non zero
	                            				episodeCNT++;
	                        			}
	                                        }
	                                }
	                        }
	
				if(recurrenceFLAG==1){
					FOLLOWUPcounter++;
					EpiTotal+=currentValue;
				}
	
	                        previousMeasurement=currentValue;
	                        previousMeasurementFU=followUpWeek;
	                        prevValueChange=valueChange;
	                }
	
	
	
	                painArray[i]=data_array[1,i];
			painStringUNS[patientId]=painStringUNS[patientId]","data_array[1,i];
	        }
	
	                EPIweek=EPIcounter;
	                EpisodeMean=EPItotal/EPIweek;
	
			if(EPI_FLAG==1&&currentValue==0){
				resolved=1;
			}else{
					detectedEpisoded++;
					EpisodeDescriptionString[patientId]=EpisodeDescriptionString[patientId]","detectedEpisoded","EPIweek","EpisodeMean;
			}
	
#####################################################
#
#    Mean Pain
#
#####################################################
	
	        AUC_denominator=(followUpWeek+1)-startweek;
	
	
	
# USING NearestNeighbor MEAN PAIN
	        if(AUC_denominator!=0){
	                meanPain=valueTotalForMean/AUC_denominator;
	        }
	
	
		noBaselineWeeks=AUC_denominator-1;
		valueTotalForMeanWithoutBaseline=valueTotalForMean-baselineValue;
	
		if(noBaselineWeeks!=0){
			noBaselineMean=valueTotalForMeanWithoutBaseline/noBaselineWeeks;
		}
	
	        if(AUC_denominator!=0){
	                meanPain_AUC=valueTotalForMean/AUC_denominator;
	        }
	
	        minPain=getMin(painArray,FUcnt1);
	        if(minPain>0){
	                 constant_pain=1;
	        }
	
	    	if(weeksNoPain/(seperateFUcnt+1)>0.90){
	        	mainly_zero=1;
	    	}
	       	maxPain=getMax(painArray,FUcnt1);
	
	        for(i=0;i<FUcnt1;i++){
	                if((meanPain-painArray[i]<-10)||(meanPain-painArray[i]>10)){
	                        varianceMoreThenOne=1;
	                }
	        }
	
	
#####################################################
#
# TRAJECTORY LOGIC KONGSTED et al. 2017
#
#####################################################
	
	        if(FUcnt1==0){
	                trajectoryId=-1;
	        }else{
	                if(varianceMoreThenOne==0){
# Persistent
	                         if(meanPain<20){
	                         	trajectoryId=4;
	                         }else if(meanPain<40){
	                                trajectoryId=3;
	                         }else if(meanPain<60){
	                                trajectoryId=2;
	                         }else if(meanPain>=60){
	                         	trajectoryId=1;
	                         }
			}else if((noBaselineMean>baselineValue)&&significantValueChange==0){
# Progressive
	                         if(meanPain<20){
	                         	trajectoryId=8;
	                         }else if(meanPain<40){
	                                trajectoryId=7;
	                         }else if(meanPain<60){
	                                trajectoryId=6;
	                         }else if(meanPain>=60){
	                         	trajectoryId=5;
	                         }
	
# Single Episodic
			}else if(weeksPain<=2&&detectedEpisoded==1&&baselineValue==0){
	                                if(maxPain<20){
	                                        trajectoryId=20;
	                                }else if(maxPain<40){
	                                         trajectoryId=19;
	                                }else if(maxPain<60){
	                                         trajectoryId=18;
	                                }else if(maxPain>=60){
	                                        trajectoryId=17;
	                                }
	
			}else if(((baselineValue-noBaselineMean>=10)&&(significantNegativeValueChange==0)&&(detectedEpisoded<2))||(resolved==1&&detectedEpisoded==1)){
				if(RAPID==1){
# Rapidly
	                         	if(meanPain<20){
	                         		trajectoryId=12;
	                         	}else if(meanPain<40){
	                               		 trajectoryId=11;
	                         	}else if(meanPain<60){
	                               		 trajectoryId=10;
	                         	}else if(meanPain>=60){
	                         		trajectoryId=9;
	                         	}
				}else{
# Gradually
	                         	if(meanPain<20){
	                         		trajectoryId=16;
	                         	}else if(meanPain<40){
	                               		 trajectoryId=15;
	                         	}else if(meanPain<60){
	                               		 trajectoryId=14;
	                         	}else if(meanPain>=60){
	                         		trajectoryId=13;
	                         	}
				}
	                }else if(detectedEpisoded>=2){
# Episodic
	                         	if(maxPain<20){
	                         		trajectoryId=24;
	                         	}else if(maxPain<40){
	                               		 trajectoryId=23;
	                         	}else if(maxPain<60){
	                               		 trajectoryId=22;
	                         	}else if(maxPain>=60){
	                         		trajectoryId=21;
	                         	}
	                }else if((meanPain-minPain>10)||(maxPain-meanPain>10)){
# Fluctuating
	                         	if(meanPain<20){
	                         		trajectoryId=28;
	                         	}else if(meanPain<40){
	                               		 trajectoryId=27;
	                         	}else if(meanPain<60){
	                               		 trajectoryId=26;
	                         	}else if(meanPain>=60){
	                         		trajectoryId=25;
	                         	}
	                }else{
# RestPatients
	                        trajectoryId=8;
	                }
	        }
	    	print "PATIENTDATA "patientId","trajectoryId","meanPain","minPain","maxPain","varianceMoreThenOne","\
			noBaselineMean","baselineValue","significantValueChange","significantNegativeValueChange","\
			detectedEpisoded","RAPID","weeksPain","painStringUNS[patientId];
	
		print "EPISODEDATA "patientId","trajectoryId","meanPain","detectedEpisoded","EpisodeDescriptionString[patientId]",,,,,"painStringUNS[patientId];
	
	        return trajectoryId;
	}
}


#####################################################
#
#	First subgroup
#
#####################################################

function createFirstSubGroup(input_array, cnt){
    	print "PATIENTDATA patientId,trajectoryId,meanPain,minPain,maxPain,varianceMoreThenOne,noBaselineMean,baselineValue,significantValueChange,significantNegativeValueChange,detectedEpisoded,RAPID,weeksPain,painStringUNS";
	print "RAWDATA patientId,unstable,stable,overall";
	for(regel=0;regel<cnt;regel++){
		for(groupCNT=0;groupCNT<FGN;groupCNT++){
			if(input_array[regel,FG]>firstGroupLimit_array[groupCNT,1]){
			}else{
				FGsubgroupCNT[groupCNT]++;
                                subjectId=input_array[regel,1];
                                if(subjectId!=prevSubjectId){
                                        uniqueSubjectCNT[groupCNT]++;
                                        uniqueSubList[groupCNT,uniqueSubjectCNT[groupCNT]-1]=subjectId;
					if(prevSubjectId!=""){

						nrOfPoints=seperateFUcnt+1;
						for(FUcnt=0;FUcnt<nrOfPoints;FUcnt++){
							point10=0;
							minFU=-100;
							maxFU=100;

							if(trajectory_array1[0,FUcnt]<=9){
								FUdiff=trajectory_array1[0,FUcnt]-10;
								if(FUdiff>minFU){
									minFU=FUdiff;
									minFU=trajectory_array1[0,FUcnt];
									minVal=trajectory_array1[1,FUcnt];
								}
							}
							if(trajectory_array[0,FUcnt]>10){
                                                                FUdiff1=trajectory_array[0,FUcnt]-10;
                                                                if(FUdiff1<maxFU){
									maxFU=FUdiff1;
                                                                        maxFU=trajectory_array[0,FUcnt];
                                                                        maxVal=trajectory_array[1,FUcnt];
                                                                }
                                                        }
							if(trajectory_array1[0,FUcnt]==9||trajectory_array[0,FUcnt]==9){
								point10=1;
								break;
							}
						}
						if(point10==0){
# value calculation at cut off point between unstable and stable
							periodDiff=maxFU-minFU;
							valueDiff=maxVal-minVal;
							if(periodDiff>0){
								coefficient=valueDiff/periodDiff;
							}
							cutOffValue=((9-minFU)*coefficient)+minVal;
							if(firstPartFUcnt!=0){
							}
							if(secondPartFUcnt!=0){
							}

						}

# assess_First_Trajectory

						trajectory1[prevSubjectId]=assess_First_Trajectory(trajectory_array1,firstPartFUcnt,prevSubjectId);



					}
					prevSubjectId=subjectId;
					seperateFUcnt=0;
					firstPartFUcnt=0;
					secondPartFUcnt=0;
                                        	trajectory_array1[0,firstPartFUcnt]=input_array[regel,2];
                                        	trajectory_array1[1,firstPartFUcnt]=input_array[regel,PN];
						firstPartFUcnt++;
				}else{
					seperateFUcnt++;
                                        	trajectory_array1[0,firstPartFUcnt]=input_array[regel,2];
                                        	trajectory_array1[1,firstPartFUcnt]=input_array[regel,PN];
						firstPartFUcnt++;
						firstPartFYarray=firstPartFYarray" "input_array[regel,PN];
				}
# for second subgroup
                                for(columns=1;columns<=NF;columns++){
                                        result_array[groupCNT,FGsubgroupCNT[groupCNT]-1,columns]=input_array[regel,columns];
                                }
    
				break;
			}
		}
	}
	if(prevSubjectId!=""){
		trajectory1[prevSubjectId]=assess_First_Trajectory(trajectory_array1,firstPartFUcnt,prevSubjectId);
	}
	printf("%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%15s\t%-15s\t%-15s\t%-15s\n",parameter_name_array[FG],"Participants","Follow-Ups","Persistent","Fluctuating","Episodic","SingleEpisodic","Rapidly","Gradually","Progressive");
	print "AGREGATEDATA "parameter_name_array[FG]",Participants,Follow-Ups,Persistent,Fluctuating,Episodic,SingleEpisodic,Rapidly,Gradually,Progressive";

	print "\n"
	for(groups=0;groups<FGN;groups++){
                for(subjects=0;subjects<uniqueSubjectCNT[groups];subjects++){
                	subject=uniqueSubList[groups,subjects];
			id=trajectory1[subject];
		        if(id>0&&id<5){
				Super=1;
                                Persistent[groups]++;
				PatientsWithPersistentPain++;
				if(id==1){
					severe_ongoing[groups]++;
				}else if(id==2){
					moderate_ongoing[groups]++;
				}else if(id==3){
					mild_ongoing[groups]++;
				}else if(id==4){
					minor_ongoing[groups]++;
				}
			}else if(id>4&&id<9){
				Super=7;
                                Progressive[groups]++;
                                PatientsWithProgressivePain++;
				if(id==5){
                                        severe_progressive[groups]++;
				}else if(id==6){
                                        moderate_progressive[groups]++;
				}else if(id==7){
                                        mild_progressive[groups]++;
				}else if(id==8){
                                        minor_progressive[groups]++;
				}
			}else if(id>8&&id<13){
				Super=5;
                                Rapidly[groups]++;
                                PatientsWithRapidlyImprovingPain++;
				if(id==9){
                                        severe_rapidly[groups]++;
				}else if(id==10){
                                        moderate_rapidly[groups]++;
				}else if(id==11){
                                        mild_rapidly[groups]++;
				}else if(id==12){
                                        minor_rapidly[groups]++;
				}
			}else if(id>12&&id<17){
				Super=6;
                                Gradual[groups]++;
                                PatientsWithGradualyImprovingPain++;
				if(id==13){
                                        severe_gradual[groups]++;
				}else if(id==14){
                                        moderate_gradual[groups]++;
				}else if(id==15){
                                        mild_gradual[groups]++;
				}else if(id==16){
                                        minor_gradual[groups]++;
				}
                        }else if(id>16&&id<21){
				Super=3;
				SingleEpisodic[groups]++;
				PatientsWithSingleEpisodicPain++;
                                if(id==17){
					severe_single_episodic[groups]++;
                                }else if(id==18){
					moderate_single_episodic[groups]++;
                                }else if(id==19){
					mild_single_episodic[groups]++;
                                }else if(id==20){
					minor_single_episodic[groups]++;
                                }
                        }else if(id>20&&id<25){
				Super=4;
                                Episodic[groups]++;
                                PatientsWithEpisodicPain++;
                                if(id==21){
                                        severe_episodic[groups]++;
                                }else if(id==22){
                                        moderate_episodic[groups]++;
                                }else if(id==23){
                                        mild_episodic[groups]++;
                                }else if(id==24){
                                        minor_episodic[groups]++;
                                }
                        }else if(id>24&&id<29){
				Super=2;
                                Fluctuating[groups]++;
                                PatientsWithFluctuatingPain++;
                                if(id==25){
                                        severe_fluctuating[groups]++;
                                }else if(id==26){
                                        moderate_fluctuating[groups]++;
                                }else if(id==27){
                                        mild_fluctuating[groups]++;
                                }else if(id==28){
                                        minor_fluctuating[groups]++;
                                }

		        }else{
				RestPatients++;
				PatientsWithOneMeasurement++;
			}

		print "RAWDATA "subject","id","id","Super","groups;
	}

		printf("%-19s\t%-19s\t%-19s\t%-19s\t%-19s\t%-19s\t%-19s\t%-19s\n",\
			"Group","Ongoing","Progressing","Rapidly","Gradually","Single","Episodic","Fluctuating");

                if(parameter_name_array[FG]=="Sex"){
                	if(groups==0){ labelFirstGroup="Male"; 
			}else{ labelFirstGroup="Female"; }
                }else if(parameter_name_array[FG]=="BMI"){
                	if(groups==0){ labelFirstGroup="Underweight"; 
			}else if(groups==1){ labelFirstGroup="Normal"; 
			}else if(groups==2){ labelFirstGroup="Overweight";
                        }else if(groups==3){ labelFirstGroup="Obese";
                        }
                }else{
                	labelFirstGroup=int(firstGroupLimit_array[groups,0])" - "int(firstGroupLimit_array[groups,1]);
                }
		if(uniqueSubjectCNT[groups]!=0){

			GROUP_TOTAL[groups]=Persistent[groups]+Progressive[groups]+Rapidly[groups]+Gradual[groups]+SingleEpisodic[groups]+Episodic[groups]+Fluctuating[groups];
			printf("%-15s\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\n", \
				labelFirstGroup,Persistent[groups],(Persistent[groups]/GROUP_TOTAL[groups])*100,\
				Progressive[groups],(Progressive[groups]/GROUP_TOTAL[groups])*100,\
				Rapidly[groups],(Rapidly[groups]/GROUP_TOTAL[groups])*100,\
				Gradual[groups],(Gradual[groups]/GROUP_TOTAL[groups])*100,\
				SingleEpisodic[groups],(SingleEpisodic[groups]/GROUP_TOTAL[groups])*100,\
				Episodic[groups],(Episodic[groups]/GROUP_TOTAL[groups])*100,\
				Fluctuating[groups],(Fluctuating[groups]/GROUP_TOTAL[groups])*100);	

			printf("%-15s\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\n", \
                                "  Severe",severe_ongoing[groups],(severe_ongoing[groups]/GROUP_TOTAL[groups])*100,severe_progressive[groups],\
				(severe_progressive[groups]/GROUP_TOTAL[groups])*100,severe_rapidly[groups],(severe_rapidly[groups]/GROUP_TOTAL[groups])*100,\
				severe_gradual[groups],(severe_gradual[groups]/GROUP_TOTAL[groups])*100,severe_single_episodic[groups], \
				(severe_single_episodic[groups]/GROUP_TOTAL[groups])*100,severe_episodic[groups],(severe_episodic[groups]/GROUP_TOTAL[groups])*100, \
				severe_fluctuating[groups],(severe_fluctuating[groups]/GROUP_TOTAL[groups])*100);

			printf("%-15s\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\n", \
                                "  Moderate",moderate_ongoing[groups],(moderate_ongoing[groups]/GROUP_TOTAL[groups])*100,moderate_progressive[groups],\
				(moderate_progressive[groups]/GROUP_TOTAL[groups])*100,moderate_rapidly[groups],(moderate_rapidly[groups]/GROUP_TOTAL[groups])*100,\
				moderate_gradual[groups],(moderate_gradual[groups]/GROUP_TOTAL[groups])*100,moderate_single_episodic[groups], \
				(moderate_single_episodic[groups]/GROUP_TOTAL[groups])*100,moderate_episodic[groups],(moderate_episodic[groups]/GROUP_TOTAL[groups])*100, \
				moderate_fluctuating[groups],(moderate_fluctuating[groups]/GROUP_TOTAL[groups])*100);

			printf("%-15s\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\n", \
                                "  Mild",mild_ongoing[groups],(mild_ongoing[groups]/GROUP_TOTAL[groups])*100,mild_progressive[groups],\
				(mild_progressive[groups]/GROUP_TOTAL[groups])*100,mild_rapidly[groups],(mild_rapidly[groups]/GROUP_TOTAL[groups])*100,\
				mild_gradual[groups],(mild_gradual[groups]/GROUP_TOTAL[groups])*100,mild_single_episodic[groups], \
				(mild_single_episodic[groups]/GROUP_TOTAL[groups])*100,mild_episodic[groups],(mild_episodic[groups]/GROUP_TOTAL[groups])*100, \
				mild_fluctuating[groups],(mild_fluctuating[groups]/GROUP_TOTAL[groups])*100);

			printf("%-15s\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\t%8s %8.1f%%\n", \
                                "  Minor",minor_ongoing[groups],(minor_ongoing[groups]/GROUP_TOTAL[groups])*100,minor_progressive[groups],\
				(minor_progressive[groups]/GROUP_TOTAL[groups])*100,minor_rapidly[groups],(minor_rapidly[groups]/GROUP_TOTAL[groups])*100,\
				minor_gradual[groups],(minor_gradual[groups]/GROUP_TOTAL[groups])*100,minor_single_episodic[groups], \
				(minor_single_episodic[groups]/GROUP_TOTAL[groups])*100,minor_episodic[groups],(minor_episodic[groups]/GROUP_TOTAL[groups])*100, \
				minor_fluctuating[groups],(minor_fluctuating[groups]/GROUP_TOTAL[groups])*100);

		}
		totUniqueSubjects+=uniqueSubjectCNT[groups];
		totFGSubjects+=FGsubgroupCNT[groups];
	}

                printf("%-15s\t%8s\t%8s\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\n", \
                        "Totals",totUniqueSubjects,totFGSubjects,PatientsWithPersistentPain,PatientsWithProgressivePain,PatientsWithRapidlyImprovingPain,\
			PatientsWithGradualyImprovingPain,PatientsWithSingleEpisodicPain,PatientsWithEpisodicPain,PatientsWithFluctuatingPain);

	print "AGREGATEDATA "parameter_name_array[FG]",Participants,Follow-Ups,Persistent,Fluctuating,Episodic,SingleEpisodic";
	for(groups=0;groups<FGN;groups++){
                if(parameter_name_array[FG]=="Sex"){
                	if(groups==0){ labelFirstGroup="Male"; 
			}else{ labelFirstGroup="Female"; }
                }else if(parameter_name_array[FG]=="BMI"){
                	if(groups==0){ labelFirstGroup="Underweight"; 
			}else if(groups==1){ labelFirstGroup="Normal"; 
			}else if(groups==2){ labelFirstGroup="Overweight";
                        }else if(groups==3){ labelFirstGroup="Obese";
                        }
                }else{
                	labelFirstGroup=int(firstGroupLimit_array[groups,0])" - "int(firstGroupLimit_array[groups,1]);
                }
	}
	for(groups=0;groups<FGN;groups++){
                if(parameter_name_array[FG]=="Sex"){
                	if(groups==0){ labelFirstGroup="Male"; 
			}else{ labelFirstGroup="Female"; }
                }else if(parameter_name_array[FG]=="BMI"){
                	if(groups==0){ labelFirstGroup="Underweight"; 
			}else if(groups==1){ labelFirstGroup="Normal"; 
			}else if(groups==2){ labelFirstGroup="Overweight";
                        }else if(groups==3){ labelFirstGroup="Obese";
                        }
                }else{
                	labelFirstGroup=int(firstGroupLimit_array[groups,0])" - "int(firstGroupLimit_array[groups,1]);
                }
	}

		print "\n";

	if(NUMBER_OF_SUBGROUPS==1){
		print "Number of classified patients: "TOTpersistent+TOTfluctuating+TOTepisodic+TOTsingle+TOTrapidly+TOTgradually+TOTprogres;
		print "Number of rest patients: "RESTpatients;
	}
	return;
}

#####################################################
#
# SECOND SUBGROUP
#
#####################################################

function createSecondSubgroup(input_array2){
        for(firstGroupNumber=0;firstGroupNumber<FGN;firstGroupNumber++){

                for(subjectsPerGroup=0;subjectsPerGroup<FGsubgroupCNT[firstGroupNumber];subjectsPerGroup++){
                        for(secondGroupNumber=0;secondGroupNumber<SGN;secondGroupNumber++){

                                if(input_array2[firstGroupNumber,subjectsPerGroup,SG]>secondGroupLimit_array[secondGroupNumber,1]){
                                }else{
                                        SGsubgroupCNT[firstGroupNumber,secondGroupNumber]++;
                                        subjectId=input_array2[firstGroupNumber,subjectsPerGroup,1];
                                        if(subjectId!=prevSubjectId){
                                                uniqueSubjectCNT2[firstGroupNumber,secondGroupNumber]++;
                                                uniqueSubjectList[firstGroupNumber,secondGroupNumber,uniqueSubjectCNT2[firstGroupNumber,secondGroupNumber]-1]=subjectId;
                                        	seperateFUcnt=0;
                                                prevSubjectId=subjectId;
	                                       	trajectory_array2[0,seperateFUcnt]=input_array2[firstGroupNumber,subjectsPerGroup,2];
                                        	trajectory_array2[1,seperateFUcnt]=input_array2[firstGroupNumber,subjectsPerGroup,PN];
					}else{
                                                seperateFUcnt++;    
                                        	trajectory_array2[0,seperateFUcnt]=input_array2[firstGroupNumber,subjectsPerGroup,2];
                                        	trajectory_array2[1,seperateFUcnt]=input_array2[firstGroupNumber,subjectsPerGroup,PN];
                                        }
                                        for(columns2=0;columns2<=NF;columns2++){
                                                results_array2[firstGroupNumber,secondGroupNumber,SGsubgroupCNT[firstGroupNumber,secondGroupNumber]-1,columns2]=input_array2[firstGroupNumber,subjectsPerGroup,columns2];
                                        }
	                                break;
                                }
                        }
                }
        }

# Title
	if(NUMBER_OF_SUBGROUPS!=3){
                printf("%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\n",\
                        parameter_name_array[FG],parameter_name_array[SG],"Participants","Follow-Ups"\
                        ,"Persistent","Fluctuating","Episodic","Single","Rapidly","Gradually","Progressing");
	}

        for(sg1=0;sg1<FGN;sg1++){
                for(sg2=0;sg2<SGN;sg2++){
                        for(subjects=0;subjects<uniqueSubjectCNT2[sg1,sg2];subjects++){
                                subject=uniqueSubjectList[sg1,sg2,subjects];

                		if(combinedTrajectory[subject]==1){
	                                Persistent[sg1,sg2]++;
	                                PatientsWithPersistentPain2++;
                		}else if(combinedTrajectory[subject]==2){
	                                Fluctuating[sg1,sg2]++;
	                                PatientsWithFluctuatingPain2++;
                		}else if(combinedTrajectory[subject]==3){
	                                SingleEpisodic[sg1,sg2]++;
	                                PatientsWithSingleEpisodicPain2++;
                		}else if(combinedTrajectory[subject]==4){
	                                Episodic[sg1,sg2]++;
	                                PatientsWithEpisodicPain2++;
                		}else if(combinedTrajectory[subject]==5){
					Rapidly[sg1,sg2]++;
					PatientsWithRapidlyPain2++;
                		}else if(combinedTrajectory[subject]==6){
					Gradually[sg1,sg2]++;
					PatientsWithGraduallyPain2++;
                		}else if(combinedTrajectory[subject]==7){
					Progres[sg1,sg2]++;
					PatientsWithProgressingPain2++;
                		}else{
	                                RestPatients2++;
                		}

                        }
                        if(parameter_name_array[FG]=="Sex"){ 
				if(sg1==0){ labelFirstGroup="Male"; 
				}else{ labelFirstGroup="Female"; }
                        }else if(parameter_name_array[FG]=="BMI"){ 
				if(sg1==0){ labelFirstGroup="Underweight"; 
				}else if(sg1==1){ labelFirstGroup="Normal"; 
				}else if(sg1==2){ labelFirstGroup="Overweight"; 
				}else if(sg1==3){ labelFirstGroup="Obese"; }
                        }else{
                                labelFirstGroup=int(firstGroupLimit_array[sg1,0])" - "int(firstGroupLimit_array[sg1,1]);
                        }
                        if(parameter_name_array[SG]=="Sex"){
                                if(sg2==0){ labelSecondGroup="Male"; 
				}else{ labelSecondGroup="Female"; }
                        }else if(parameter_name_array[SG]=="BMI"){
                                if(sg2==0){ labelSecondGroup="Underweight"; 
				}else if(sg2==1){ labelSecondGroup="Normal"; 
				}else if(sg2==2){ labelSecondGroup="Overweight"; 
				}else if(sg2==3){ labelSecondGroup="Obese"; }
                       }else{
                                labelSecondGroup=int(secondGroupLimit_array[sg2,0])" - "int(secondGroupLimit_array[sg2,1]);
                        }
                	if(uniqueSubjectCNT2[sg1,sg2]!=0){
				TOTAL_2DIMENSIONS[sg1,sg2]=Persistent[sg1,sg2]+Fluctuating[sg1,sg2]+Episodic[sg1,sg2]+SingleEpisodic[sg1,sg2]+\
							Rapidly[sg1,sg2]+Gradually[sg1,sg2]+Progres[sg1,sg2];

                        	printf("%-15s\t%-15s\t%8s\t%8s\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\n",\
					labelFirstGroup,labelSecondGroup,TOTAL_2DIMENSIONS[sg1,sg2], \
					SGsubgroupCNT[sg1,sg2],(Persistent[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100,\
                                	(Fluctuating[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100, \
					(Episodic[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100, \
					(SingleEpisodic[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100, \
					(Rapidly[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100, \
					(Gradually[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100,\
					(Progres[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])*100);

				print "AGREGATEDATA "labelFirstGroup","labelSecondGroup","TOTAL_2DIMENSIONS[sg1,sg2]\
					","SGsubgroupCNT[sg1,sg2]","(Persistent[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(Fluctuating[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(Episodic[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(SingleEpisodic[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(Rapidly[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(Gradually[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2])\
					","(Progres[sg1,sg2]/TOTAL_2DIMENSIONS[sg1,sg2]);
			}
                }
                totUniqueSubjects+=uniqueSubjectCNT2[sg1,sg2]
                totFGSubjects+=FGsubgroupCNT[sg1,sg2];
        }

		print "\n";
	if(NUMBER_OF_SUBGROUPS==2){
        	printf("%-15s\t%-15s\t%8s\t%8s\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\n", \
			"Totals","",(PatientsWithPersistentPain2+PatientsWithFluctuatingPain2+PatientsWithEpisodicPain2+\
				PatientsWithSingleEpisodicPain2+PatientsWithRapidlyPain2+\
				PatientsWithGraduallyPain2+PatientsWithProgressingPain2),\
				totFGSubjects,PatientsWithPersistentPain2, \
				PatientsWithFluctuatingPain2,PatientsWithEpisodicPain2,\
				PatientsWithSingleEpisodicPain2,PatientsWithRapidlyPain2,\
				PatientsWithGraduallyPain2,PatientsWithProgressingPain2);
        	print "Number of classified patients: "PatientsWithPersistentPain2+PatientsWithFluctuatingPain2+PatientsWithEpisodicPain2+PatientsWithSingleEpisodicPain2+PatientsWithRapidlyPain2+PatientsWithGraduallyPain2+PatientsWithProgressingPain2;
        	print "Number of rest patients: "RestPatients2;
        	print "Number of patients with one pain measurement: "PatientsWithOneMeasurement2;
	}
        return;
}

#####################################################
#
# THIRD SUBGROUP
#
#####################################################

function createThirdSubgroup(input_array3){

	for(firstSubGroupNumber=0;firstSubGroupNumber<FGN;firstSubGroupNumber++){
            	for(secondSubGroupNumber=0;secondSubGroupNumber<SGN;secondSubGroupNumber++){
                    	for(secondSubGroupCNT=0;secondSubGroupCNT<SGsubgroupCNT[firstSubGroupNumber,secondSubGroupNumber];secondSubGroupCNT++){
                            	for(thirdGroupNumber=0;thirdGroupNumber<TGN;thirdGroupNumber++){

                                    	if(input_array3[firstSubGroupNumber,secondSubGroupNumber,secondSubGroupCNT,TG]>thirdGroupLimit_array[thirdGroupNumber,1]){
                                    	}else{
                                            	thirdGroupCNT[firstSubGroupNumber,secondSubGroupNumber,thirdGroupNumber]++;
                                            	subjectId=input_array3[firstSubGroupNumber,secondSubGroupNumber,secondSubGroupCNT,1];
                                            	if(subjectId!=prevSubjectId){
                                                	uniqueSubjectCNT3[firstSubGroupNumber,secondSubGroupNumber,thirdGroupNumber]++;
                                                	uniqueSubjectList3[firstSubGroupNumber,secondSubGroupNumber,thirdGroupNumber,uniqueSubjectCNT3[firstSubGroupNumber,secondSubGroupNumber,thirdGroupNumber]-1]=subjectId;
                                                	prevSubjectId=subjectId;
                                                	seperateFUcnt=0;
                                            	}else{
                                                	seperateFUcnt++;
                                        	}
						break;
                                    	}
                            	}
                    	}
            	}
    	}
                printf("%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\n",\
                        parameter_name_array[FG],parameter_name_array[SG],parameter_name_array[TG],"Participants","Follow-Ups"\
                        ,"Persistent","Fluctuating","Episodic","SingleEpisodic","Rapidly","Gradually","Progressing");

       	for(subgroup1=0;subgroup1<FGN;subgroup1++){ 
        	for(subgroup2=0;subgroup2<SGN;subgroup2++){
                	for(subgroup3=0;subgroup3<TGN;subgroup3++){

                       		for(subjects3=0;subjects3<uniqueSubjectCNT3[subgroup1,subgroup2,subgroup3];subjects3++){
                                        subject=uniqueSubjectList3[subgroup1,subgroup2,subgroup3,subjects3];
                
					if(combinedTrajectory[subject]==1){
                                        	Persistent3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithPersistentPain3++;
                			}else if(combinedTrajectory[subject]==2){
                                        	Fluctuating3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithFluctuatingPain3++;
                			}else if(combinedTrajectory[subject]==3){
                                        	SingleEpisodic3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithSingleEpisodicPain3++;
                			}else if(combinedTrajectory[subject]==4){
                                        	Episodic3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithEpisodicPain3++;
                			}else if(combinedTrajectory[subject]==5){
                                        	Rapidly3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithRapidlyPain3++;
                			}else if(combinedTrajectory[subject]==6){
                                        	Gradually3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithGraduallyPain3++;
                			}else if(combinedTrajectory[subject]==7){
                                        	Progres3[subgroup1,subgroup2,subgroup3]++;
                                        	PatientsWithProgressingPain3++;
                			}else{
						RestPatients3++;
                			}
						
				}
                                if(parameter_name_array[FG]=="Sex"){
                                        if(subgroup1==0){
                                                labelFirstGroup="Male";
                                        }else{
                                                labelFirstGroup="Female";
                                        }
                                }else if(parameter_name_array[FG]=="BMI"){
                                        if(subgroup1==0){
                                                labelFirstGroup="Underweight";  
                                        }else if(subgroup1==1){
                                                labelFirstGroup="Normal";       
                                        }else if(subgroup1==2){
                                                labelFirstGroup="Overweight";   
                                        }else if(subgroup1==3){
                                                labelFirstGroup="Obese";        
                                        }
                                }else{
                                        labelFirstGroup=int(firstGroupLimit_array[subgroup1,0])" - "int(firstGroupLimit_array[subgroup1,1]);
                                }
                                if(parameter_name_array[SG]=="Sex"){
                                        if(subgroup2==0){
                                                labelSecondGroup="Male";
                                        }else{
                                                labelSecondGroup="Female";
                                        }
                                }else if(parameter_name_array[SG]=="BMI"){
                                        if(subgroup2==0){
                                                labelSecondGroup="Underweight";
                                        }else if(subgroup2==1){
                                                labelSecondGroup="Normal";
                                        }else if(subgroup2==2){
                                                labelSecondGroup="Overweight";
                                        }else if(subgroup2==3){
                                                labelSecondGroup="Obese";
                                        }
                                }else{
                                        labelSecondGroup=int(secondGroupLimit_array[subgroup2,0])" - "int(secondGroupLimit_array[subgroup2,1]);
                                }
                               	if(parameter_name_array[TG]=="Sex"){
                                        if(subgroup3==0){
                                                labelThirdGroup="Male";
                                        }else{
                                                labelThirdGroup="Female";
                                        }
                                }else if(parameter_name_array[TG]=="BMI"){
                                        if(subgroup3==0){
                                                labelThirdGroup="Underweight";  
                                        }else if(subgroup3==1){
                                                labelThirdGroup="Normal";       
                                        }else if(subgroup3==2){
                                                labelThirdGroup="Overweight";   
                                        }else if(subgroup3==3){
                                                labelThirdGroup="Obese";        
                                        }
                                }else{
                                        labelThirdGroup=int(thirdGroupLimit_array[subgroup3,0])" - "int(thirdGroupLimit_array[subgroup3,1]);
                                }


				if(uniqueSubjectCNT3[subgroup1,subgroup2,subgroup3]!=0){

					TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3]=Persistent3[subgroup1,subgroup2,subgroup3]+Fluctuating3[subgroup1,subgroup2,subgroup3]+\
						Episodic3[subgroup1,subgroup2,subgroup3]+SingleEpisodic3[subgroup1,subgroup2,subgroup3]+Rapidly3[subgroup1,subgroup2,subgroup3]+\
						Gradually3[subgroup1,subgroup2,subgroup3]+Progres3[subgroup1,subgroup2,subgroup3];

                                        printf("%-15s\t%-15s\t%-15s\t%8s\t%8s\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\t%8.1f\n",\
					labelFirstGroup,labelSecondGroup,labelThirdGroup,TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3],thirdGroupCNT[subgroup1,subgroup2,subgroup3],\
					(Persistent3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(Fluctuating3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(Episodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(SingleEpisodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(Rapidly3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(Gradually3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100,\
					(Progres3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])*100);
	
					print "AGREGATEDATA "labelFirstGroup","labelSecondGroup","labelThirdGroup","TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3]\
						","thirdGroupCNT[subgroup1,subgroup2,subgroup3]","(Persistent3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(Fluctuating3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(Episodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(SingleEpisodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(Rapidly3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(Gradually3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
						","(Progres3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3]);

                                        bruteforce_line=bruteforce_line","labelFirstGroup","labelSecondGroup","labelThirdGroup","TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3]\
                                                ","(Persistent3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
                                                ","(Progres3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
                                                ","(Rapidly3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
                                                ","(Gradually3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
                                                ","(Fluctuating3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
                                                ","(Episodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3]);
						","(SingleEpisodic3[subgroup1,subgroup2,subgroup3]/TOTAL_3DIMENSIONAL[subgroup1,subgroup2,subgroup3])\
				}
			}
                }
        }
        if(NUMBER_OF_SUBGROUPS==3){
                print "BRUTEFORCE "DATASET_NAME","parameter_name_array[FG]"("FG"),"FGN","parameter_name_array[SG]"("SG"),"SGN","parameter_name_array[TG]"("TG"),"TGN""bruteforce_line;
        }
	if(NUMBER_OF_SUBGROUPS==3){

        	printf("%-15s\t%-15s\t%-15s\t%8s\t%8s\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\t%8.0f\n", \
			"Totals","","",(PatientsWithPersistentPain2+ PatientsWithFluctuatingPain2+PatientsWithEpisodicPain2+\
				PatientsWithSingleEpisodicPain2+PatientsWithRapidlyPain2+\
				PatientsWithGraduallyPain2+PatientsWithProgressingPain2),\
				totFGSubjects,PatientsWithPersistentPain2, \
				PatientsWithFluctuatingPain2,PatientsWithEpisodicPain2,\
				PatientsWithSingleEpisodicPain2,PatientsWithRapidlyPain2,\
				PatientsWithGraduallyPain2,PatientsWithProgressingPain2);
        	print "Number of classified patients: "PatientsWithPersistentPain3+PatientsWithFluctuatingPain3+PatientsWithEpisodicPain3+PatientsWithSingleEpisodicPain3+PatientsWithRapidlyPain3+PatientsWithGraduallyPain3+PatientsWithProgressingPain3;
        	print "Number of rest patients: "RestPatients3;
        	print "Number of patients with one pain measurement: "PatientsWithOneMeasurement3;
	}
        return;
}


BEGIN{
	minValue=1000;
	maxValue=0;
	secondMinValue=1000;
	secondMaxValue=0;
        thirdMinValue=1000;
        thirdMaxValue=0;
	line=0;

#########################################################
#
# Hardcoded names of studies for SMT IPD dataset and 
# Nordic SMS LBP studies
#
########################################################
        studyName[1]="Vismara"; 
	studyName[2]="Wilkey"; 
	studyName[3]="Rasmussen"; 
	studyName[4]="Zaproudina"; 
	studyName[5]="Walker"; 
	studyName[6]="Peterson"; 
	studyName[7]="BeamTrial"; 
	studyName[8]="Cecchi"; 
	studyName[9]="Learman"; 
	studyName[10]="Balthazard"; 
	studyName[11]="Gudavelli"; 
	studyName[12]="Hondras"; 
	studyName[13]="Ferreira"; 
	studyName[14]="Bronfort"; 
	studyName[15]="BRLPBronfort"; 
	studyName[16]="Skillgate"; 
	studyName[17]="Haas"; 
	studyName[18]="Hsieh"; 
	studyName[19]="Hidalgo"; 
	studyName[20]="Xia"; 
	studyName[21]="Verma"; 
	
	studyName[22]="Nordic_LBP_subpopulation";
}{
        if(NR==1){ 
                for(i=0;i<=NF;i++){
                        parameter_name_array[i]=$i;
                }       
                next;
        }else{
	        subjectId=$1
        	if(subjectId!=prevSubjectId){
                	prevSubjectId=subjectId;
               	 	subjectCNT++;
			populationBaseline_array[subjectCNT-1]=$PN;
			followupCNT[subjectId]=0; 
		}else{
			followupCNT[subjectId]++;
		}
		
		measurementCNT++
        	studyId=$3
        	if(studyId!=prevStudyID){
			if(studyList!=""){
                	studyList=studyList","studyId;
                	studyNameList=studyNameList","studyName[studyId];
			}else{
                	studyList=studyId;
                	studyNameList=studyName[studyId];
			}
                	studycnt++;
                	prevStudyID=studyId;
        	}
		
		if($FG<minValue){
			minValue=$FG
		}
		if($FG>maxValue){
			maxValue=$FG
		}
		if(NUMBER_OF_SUBGROUPS>=2){	
			if($SG<secondMinValue){
				secondMinValue=$SG;
			}
			if($SG>secondMaxValue){
				secondMaxValue=$SG;
			}
		}
		if(NUMBER_OF_SUBGROUPS==3){	
                	if($TG<thirdMinValue){
                        	thirdMinValue=$TG;
                	}
                	if($TG>thirdMaxValue){
                        	thirdMaxValue=$TG;
                	}
		}
		for(i=1;i<=NF;i++){
			data_array[line,i]=$i;
			if(i==FG){
				FGdataCNT++;
				FGdata[FGdataCNT-1]=$FG;
			}
			if(NUMBER_OF_SUBGROUPS>=2){
				if(i==SG){
                                	SGdataCNT++;
                                	SGdata[SGdataCNT-1]=$SG;
                        	}
			}
			if(NUMBER_OF_SUBGROUPS==3){
				if(i==TG){
                                        TGdataCNT++;
                                        TGdata[TGdataCNT-1]=$TG;
                                }
			}
		}
		line++;	
	}
}END{
	firstGroupMean=calcAvg(FGdata,FGdataCNT);
        secondGroupMean=calcAvg(SGdata,SGdataCNT);
        thirdGroupMean=calcAvg(TGdata,TGdataCNT);

	print "Dataset = "DATASET_NAME;
	print "Parameter name = "parameter_name_array[PN];
	print "Number of subjects = "subjectCNT;
	print "Number of measurements = "measurementCNT-1;
	print "Number of studies = "studycnt;
        print "Name of studies = "studyNameList;
	print " ";

	print "PROGRAMINFO Parameter name,"parameter_name_array[PN];

	RANGE=maxValue-minValue;
	if(FGN!=0){
		groupSize=RANGE/FGN;
	}
	print "PROGRAMINFO FIRST subgroup,"parameter_name_array[FG]

	if(parameter_name_array[FG]!="BMI"){
		if(FGN==2){ 
			firstGroupLimit_array[0,0]=minValue;
			firstGroupLimit_array[0,1]=firstGroupMean;
			firstGroupLimit_array[1,0]=firstGroupMean;
			firstGroupLimit_array[1,1]=maxValue+0.001;
		}else{
			for(i=0;i<FGN;i++){
				if(i==0){
					minGroupValue=minValue;
				}
				firstGroupLimit_array[i,0]=minGroupValue;
				if(i==FGN-1){
					firstGroupLimit_array[i,1]=minGroupValue+groupSize+0.001;
				}else{
					firstGroupLimit_array[i,1]=minGroupValue+groupSize;
				}
				minGroupValue=minGroupValue+groupSize;
			}
		}
	}else{
		# BMI has predetermined limits
		FGN=4;
        	firstGroupLimit_array[0,0]=10;
        	firstGroupLimit_array[0,1]=18.5;
        	firstGroupLimit_array[1,0]=18.5;
        	firstGroupLimit_array[1,1]=25;
        	firstGroupLimit_array[2,0]=25;
        	firstGroupLimit_array[2,1]=30;
        	firstGroupLimit_array[3,0]=30;
        	firstGroupLimit_array[3,1]=80;
	}
        if(NUMBER_OF_SUBGROUPS>=2){
                secondRange=secondMaxValue-secondMinValue;
		if(SGN!=0){
                	secondGroupSize=secondRange/SGN;
		}
                print "PROGRAMINFO SECOND subgroup,"parameter_name_array[SG]
                if(parameter_name_array[SG]!="BMI"){
                       if(SGN==2){ 
                                secondGroupLimit_array[0,0]=secondMinValue;
                                secondGroupLimit_array[0,1]=secondGroupMean;
                                secondGroupLimit_array[1,0]=secondGroupMean;
                                secondGroupLimit_array[1,1]=secondMaxValue+0.001;
                        }else{
                                for(j=0;j<SGN;j++){
                                        if(j==0){ 
                                                minSecondGroupValue=secondMinValue;
                                        }
                                        secondGroupLimit_array[j,0]=minSecondGroupValue
                                        if(j==SGN-1){
                                                secondGroupLimit_array[j,1]=minSecondGroupValue+secondGroupSize+0.001;
                                        }else{
                                                secondGroupLimit_array[j,1]=minSecondGroupValue+secondGroupSize;
                                        }
                                        minSecondGroupValue=minSecondGroupValue+secondGroupSize;
                                }
                        }
                }else{
                        # BMI has predetermined limits
                        SGN=4;
                        secondGroupLimit_array[0,0]=10;
                        secondGroupLimit_array[0,1]=18.5;
                        secondGroupLimit_array[1,0]=18.5;
                        secondGroupLimit_array[1,1]=25;
                        secondGroupLimit_array[2,0]=25;
                        secondGroupLimit_array[2,1]=30;
                        secondGroupLimit_array[3,0]=30;
                        secondGroupLimit_array[3,1]=80;
                }
        }
        if(NUMBER_OF_SUBGROUPS==3){
                thirdRange=thirdMaxValue-thirdMinValue;
                thirdGroupSize=thirdRange/TGN;
                print "PROGRAMINFO THIRD subgroup,"parameter_name_array[TG];

                if(parameter_name_array[TG]!="BMI"){
                        for(k=0;k<TGN;k++){ 
                                if(k==0){
                                        minThirdGroupValue=thirdMinValue;
                                } 
                                thirdGroupLimit_array[k,0]=minThirdGroupValue; 
                                if(k==TGN-1){
                                        thirdGroupLimit_array[k,1]=minThirdGroupValue+thirdGroupSize+0.001;
                                }else{
                                        thirdGroupLimit_array[k,1]=minThirdGroupValue+thirdGroupSize;
                                }
                                minThirdGroupValue=minThirdGroupValue+thirdGroupSize;
                        }
                }else{
                        # BMI has predetermined limits
                        TGN=4;
                        thirdGroupLimit_array[0,0]=10;
                        thirdGroupLimit_array[0,1]=18.5;
                        thirdGroupLimit_array[1,0]=18.5;
                        thirdGroupLimit_array[1,1]=25;
                        thirdGroupLimit_array[2,0]=25;
                        thirdGroupLimit_array[2,1]=30;
                        thirdGroupLimit_array[3,0]=30;
                        thirdGroupLimit_array[3,1]=80;
                }
        }

	createFirstSubGroup(data_array,line-1);

        if(NUMBER_OF_SUBGROUPS>=2){
                createSecondSubgroup(result_array);             
                print "\n"
        }
        if(NUMBER_OF_SUBGROUPS==3){
                createThirdSubgroup(results_array2);
        }

}'> ${FILENAME}.output;

PARAM_NAME=`grep "PROGRAMINFO Parameter name" ${FILENAME}.output |awk -F, '{print $2}'`
if [ ${SUBGROUP_NUMBER} -eq 1 ] ; then
	FIRST_GROUP=`grep "PROGRAMINFO FIRST subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	AGREGATE_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_SA.csv
	RAWDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_RAWDATA_SA.csv
	PATIENTDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_PATIENTDATA_SA.csv
	EPISODEDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_EPISODEDATA_SA.csv
elif [ ${SUBGROUP_NUMBER} -eq 2 ] ; then
	FIRST_GROUP=`grep "PROGRAMINFO FIRST subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	SECOND_GROUP=`grep "PROGRAMINFO SECOND subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	AGREGATE_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_SA.csv
	RAWDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_RAWDATA_SA.csv
	PATIENTDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_PATIENTDATA_SA.csv
elif [ ${SUBGROUP_NUMBER} -eq 3 ] ; then
	FIRST_GROUP=`grep "PROGRAMINFO FIRST subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	SECOND_GROUP=`grep "PROGRAMINFO SECOND subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	THIRD_GROUP=`grep "PROGRAMINFO THIRD subgroup" ${FILENAME}.output |awk -F, '{print $2}'`
	AGREGATE_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_${THIRD_GROUP_NUMBER}_${THIRD_GROUP}.csv
	RAWDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_${THIRD_GROUP_NUMBER}_${THIRD_GROUP}_RAWDATA.csv
	PATIENTDATA_FILENAME=${FILENAME}_${PARAM_NAME}_${SUBGROUP_NUMBER}_${FIRST_GROUP_NUMBER}_${FIRST_GROUP}_${SECOND_GROUP_NUMBER}_${SECOND_GROUP}_${THIRD_GROUP_NUMBER}_${THIRD_GROUP}_PATIENTDATA.csv
fi

# 0=stdOut, 1=AgregateFile, 2=RawData, 3=Bruteforce 4=trajectory"
if [ $OUTPUT_OPTION -eq 0 ] ; then
	cat ${FILENAME}.output |grep -v AGREGATEDATA|grep -v RAWDATA|grep -v PROGRAMINFO|grep -v PATIENTDATA|grep -v BRUTEFORCE|grep -v EPISODEDATA;
elif [ $OUTPUT_OPTION -eq 1 ] ; then
	cat ${FILENAME}.output |grep -v AGREGATEDATA|grep -v RAWDATA|grep -v PROGRAMINFO|grep -v PATIENTDATA|grep -v BRUTEFORCE|grep -v EPISODEDATA;
	grep AGREGATEDATA ${FILENAME}.output| cut -c13- > RESULTS/${AGREGATE_FILENAME};
elif [ $OUTPUT_OPTION -eq 2 ] ; then
	cat ${FILENAME}.output |grep -v AGREGATEDATA|grep -v RAWDATA|grep -v PROGRAMINFO|grep -v PATIENTDATA|grep -v BRUTEFORCE|grep -v EPISODEDATA;
	grep AGREGATEDATA ${FILENAME}.output| cut -c13- > RESULTS/${AGREGATE_FILENAME};
	grep RAWDATA ${FILENAME}.output| cut -c8- > RESULTS/${RAWDATA_FILENAME};
	grep EPISODEDATA ${FILENAME}.output| cut -c12- > RESULTS/${EPISODEDATA_FILENAME};
	grep PATIENTDATA ${FILENAME}.output| cut -c12- > RESULTS/${PATIENTDATA_FILENAME};
elif [ $OUTPUT_OPTION -eq 3 ] ; then
	grep BRUTEFORCE ${FILENAME}.output| cut -c11- | tee -a ~/VU_data/BF_trajectory_1_param.csv;
elif [ $OUTPUT_OPTION -eq 4 ] ; then
	cat ${FILENAME}.output |grep -v AGREGATEDATA|grep -v RAWDATA|grep -v PROGRAMINFO|grep -v PATIENTDATA|grep -v BRUTEFORCE|grep -v TRAJECTORY|grep -v REVENG;
	grep PATIENTDATA ${FILENAME}.output| cut -c12- > RESULTS/${PATIENTDATA_FILENAME};
	grep RAWDATA ${FILENAME}.output| cut -c8- > RESULTS/${RAWDATA_FILENAME};
	grep REVENG ${FILENAME}.output| cut -c7- > RESULTS/REV_ENG.csv
fi

rm ${FILENAME}.slim
rm ${FILENAME}.tmp
rm ${FILENAME}.output

